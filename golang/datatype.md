# 배열
* go의 배열은 동일한 타입의 원소가 연속된 블록에 저장되는 고정된 길이(fixed-length) 데이터 타입
<pre><code>
    //다섯 개의 원소로 구성된 정수 배열을 선언하기
    var array [5]int
    //다섯 개의 각 원소를 지정된 값으로 초기화
    array := [5]int{10, 20, 30, 40, 50}
    //배열의 길이는 초기화되는 값의 숫자에 의해 자동으로 결정
    array := [...]int{10, 20, 30, 40, 50}
    //배열의 일부요소만 초기화 선언 나머지는 0으로 초기화
    array := [5]int{1: 10, 2: 20}
    //다섯개의 원소를 가지는 정수포인터 배열 선언
    array := [5]*int{0: new(int), 1: new(int)}
</code></pre>
* 포인터의 배열을 복사하면 포인터가 가리키는 주소의 값이 아니라 포인터 값 자체가 복사된다.
* 함수에 배열을 전달하면 값이 전달되어 비효율적이다. 함수에는 포인터변수를 사용

# 슬라이스
* 슬라이스는 동적 배열의 개념으로 구현되었기 때문에 필요에 따라 컬렉션의 크기를 늘리거나 줄일 수 있다.
* 메모리가 연속적인 블록으로 할당되기 때문에 인덱싱, 반복 및 가비지 컬렉션에 최적화
<pre><code>
    //길이를 명시하여 문자열 슬라이스를 생성하는 방법
    slice := make([]string, 5)
    //길이와 최대용량을 명시하여 
    slice := make([]stirng, 3, 5)
    //길이보다 작은 용량을 지정하면 컴파일 에러
    //슬라이스 리터럴을 이용한 슬라이스 생성
    slice := []string{"Red", "Green", "Yellow", "Pink"}
    slice := []int{10, 20, 30}
    //인덱스 위치를 이용해 생성
    slice := []string{99: ""}
    //배열과 슬라이스의 차이점은 [] 사이에 값을 지정하는가 아닌가
    array := [3]int{10, 20, 30}
    slice := []int{10, 20, 30}
    // nil 정수 슬라이스 생성
    var slice []int
    // make 함수를 이용해 빈 정수 슬라이스를 생성
    slice := make([]int, 0)
    // 슬라이스 표현식을 이용해 빈 정수 슬라이스를 생성
    slice := []int{}
</code></pre>
* 슬라이스의 크기를 확장할때는 go의 내장함수인 append()를 이용
* append() 함수는 사용 가능한 여분의 용량을 먼저 사용, 용량이 한계치에 달하면 새로운 내부 배열을 생성한다.
* 슬라이스를 사용할때 주의점은 어떤 슬라이스들이 내부 배열을 공유하는지 잊기 쉽다.
* 슬라이스의 용량을 설정할 때 길이와 같은 값을 지정하면 append 작업이 처음으로 실행될 때 내부 배열이 분리된다.
- 슬라이스는 배열 생성후 그를 참조하는 포인터 주소 배열을 이용하는 개념이므로 값의 참조,s 복사 여부를 확인해야 함
* 함수에 슬라이스를 전달하면 슬라이스의 참조 값만 전달 되며 값은 전달 하지 않음.

#  맵
* 맵(map)은 키/값의 쌍에 대한 정렬 없는 (unordered) 컬렉션을 제공하는 데이터 구조
* 키를 이용해 데이터를 빠르게  조회할 수 있는 구조(해쉬테이블을 이용)
* 맵의 키는 == 연산자를 이용한 비교식에 사용될 수 있는 값이라면 내장 타입 구조체 모두 사용 할 수 있다.
* 다만 슬라이스와 함수 그리고 슬라이스를 가진 구조체는 사용할 수 없다.
* nil 맵은 키/값을 저장 할 수 없다.
* 맵에 존재하지 않는 키 값을 구하면 0만 얻게 된다. 따라서 요청한 키가 없어서 0 이 나왔는지 아니면 그 키값이 카리키는 원소가 0인지 구분할 수 없다.
* 맵은 유연함에 강점을 갖지만 프로세싱 파워가 높다. 그러나 go 언어의 구조체는 다른 언어에 비해 빠른 처리를 한다.
* 생성 및 초기화
<pre><code>
    //string 타입의 키와 int 타입의 값을 갖는 맵을 생성
    dict := make(map[string]int)
    //string 타입의 키와 값을 갖는 맵 생성
    dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}
    //문자열 슬라이스를 키로 사용하는 맵은 컴파일러 예외
    dict := map[[]string]int{} : invalid map key type []string
    //문자열 슬라이스를 값으로 사용
    dict := map[int][]string{}
    //맵을 선언하기만 하면 'nil' 맵이 생성
    var colors map[string]string
    //맵에서 값과 키의 존재여부 확인하는 방법
    value, exists := color["Blue"]
    if exists {
        fmt.Println(value)
    }
    //맵에서 값을 조회한 후 확인하는 방법
    value := color["Blue"]
    if value != "" {
        fmt.Print(value)
    }
    //키"Coral"에 해당하는 키와 값의 쌍을 제거
    delete(colors, "Coral")
</code></pre>
# 바이트 슬라이스
* 파일의 입출력 연산에 사용된다.
* 나머지는 전부 슬라이스와 같다.

## 상수 <고마스터하기>
## 상수 생성자 iota <고마스터하기>
## go 언어의 포인터 <고마스터하기>
## 날짜와 시간다루기
## for 루프
## range 키워드
### 요약
- 배열은 슬라이스와 맵을 구현하기 위한 일종의 빌딩 블록 역활을 담당한다.
- 슬라이스는 Go에서 데이터의 컬렉션을 다루기 위한 가장 보편화된 방법이다. 맵은 키와 값의 쌍을 다룰 때 유용하다.
- make 내장 함수를 이용하면 슬라이스와 맵의 초기 길이 및 용량을 지정하여 생성할 수 있다.
- 슬라이스와 맵 리터럴을 이용하면 선언 시점에 초깃값을 함께 지정할 수도 있다.
- 슬라이스는 용량의 제한을 가지고 있지만 append 내장 함수를 통해 확장이 가능하다.
- len 내장 함수를 호출하면 슬라이스나 맵의 길이를 알아낼 수 있다.
- cap 내장 함수는 슬라이스에 대해서만 호출할 수 있다.
- 합성을 이용하면 다차원 배열과 다차원 슬라이스를 활용할 수 있다. 또한 슬라이스와 다른 맵을 값으로 저장하는 맵을 생성할 수도 있다. 슬라이스는 맵의 키로 활용할 수는 없다.
- 슬라이스나 맵을 함수에 전달하는 작업은 기반 데이터 구조의 복사본을 생성하지 않으므로 자원 활요에 대한 비용 측면에서 이점이 있다.

### todo
- copy() 함수
- sort.Slice() 로 정렬하기

